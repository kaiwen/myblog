---
title: "多级回馈队列"
date: 2023-02-27
featured_image: '/images/mlfq-1.jpg'
draft: false
---
操作系统调度算法有很多种，Linux的[CFS](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler)很出名，Windows的呢？今天来讲Windows的调度器，Windows 10中使用的就是它[^win]--多级回馈队列(**Multi Level Feedback Queue**)。

为了讲清楚问题，需要从头讲起。

[^win]: https://www.quora.com/Which-type-of-scheduling-algorithm-is-used-by-windows-10

## 调度的问题
如果给你一些任务，并且已知每个任务的运行时间情况下(运行时间不可预测先不考虑)，应该怎么调度才是最优呢？

这里说最优那得先说评估标准是什么？否则很难回答这个问题。

我们用两个独立的标准来评估调度器，一个是**周转时间(turnaround time)**，任务从提交到最终完成的时间，这个中间的时间（duration）即是周转时间，从任务的角度看，周转时间就是--要尽快完成，提交了最好就一直运行，不要运行其他的，这里的问题是每个任务都是这么想的。

另一个评估标准是**响应时间(response time)**，对于有交互的任务来说，应该尽快响应，想像一下，如果你在shell敲入命令，每敲一个字符还要等几百毫秒，那会感觉卡顿，体验完全不好，这种和用户交互的系统要做到体验好，尽快响应。响应时间定义为任务提交后的第一次执行时间。

### 标准：周转时间(turnaround time)
根据之前的定义，周转时间 **`T_turnaround = T_complete - T_arrival`**

我们从最简单的例子说起。假设在时间0来了三个任务，每个任务我们预先知道要运行10s，那最简单的FIFO情况下会怎样呢。

#### 尝试一： FIFO
运行调度图大约如下

![mlfq-2](/images/mlfq-2.jpg)

可以看到，同时到达，三个任务依次运行，平均周转时间为`t=(10+20+30)/3=20`s

这里可能会有问题，对于时间长度不一的任务，调度不是最优的，比如，A需要100s，B和C都只需要10s的情况下，`t=(100+110+120)/3=110`s，平均周转110秒，如果调下顺序，B和C排到A的前面，则时间可以降到`t=(10+20+120)/3=50`s，一半以下。从“体感”上说，如果A需要运行一天一夜，B和C只运行1秒钟，则对于B和C无法忍受。

![mlfq-3](/images/mlfq-3.jpg)

![mlfq-4](/images/mlfq-4.jpg)

*(总时间长度并没有变，但是短期任务的“体感“提升了。)*

让运行时间短的任务先运行是一种优化，叫做**SJF(Shortest Job First)**

#### 尝试二： STCF (Shortest Time-to-Completion First)
SJF只讨论了同一时间来的任务统筹安排，如果是不同时间来的呢？这取决与任务是否可以抢占。比如，A是个需要运行很久的任务，运行了10s后，来了两个短任务B和C。如果没有抢占的话，B和C必须等到A运行完了才能运行，周转时间`t=(100+(110-10)+(120-10))/3=103.33`s

![mlfq-5](/images/mlfq-5.jpg)

如果有抢占的话，任务加入时，就让能最短时间完成的任务先执行，上图的时间可以优化为`t=((120-0)+(20-10)+(30-10))/3=50`s，周转时间降低了。

![mlfq-6](/images/mlfq-6.jpg)

这种让最短完成时间的任务优先运行的方法就是**STCF**。

这和超市排队结账差不多，从老板的角度看，就是让能尽快结完的尽快结 😆️

### 标准：响应时间(response time)
另一个标准，响应时间，通常适用于我们的交互程序，shell, word，ide, browser等；用户的输入需要及时响应，这个就不多赘述了。

我们让响应时间 **`T_response = T_firstrun - T_arrival`**

按这个标准衡量，SJF或者STCF的响应时间并不好。如下图三个任务0时到达，每个运行5s，平均响应时间是`t=(0+5+10)/3=5`s，其中C等了10秒，你能想像用户输入一个字符等待了10s才有响应吗。

一个能直接想到的办法就是轮询，如果采用分片的方式轮询(RR)则每个任务都可以公平的得到交互时间，`t=(0+1+2)/3=1`s，这似乎是最好的方式了，每个任务都尽快运行一阵，但是RR也有自己的问题，它本质上拉长了所有任务的完成时间，使大家的完成时间都往后拖了。

![mlfq-7](/images/mlfq-7.jpg)

所以，**完成时间和响应时间没法完全兼顾**，要想尽快完成，就要持久运行一个任务，但持久运行一个任务，其他交互任务又没法执行；要想响应速度快，就要尽快的切换，但是大量切换又拉长了所有任务的完成时间。所以这就是一场trade-off，不可兼得。可不可以交互式任务多切换，非交互式任务少切换呢？这个就是多级回馈队列的功能了。

## 多级回馈队列 (Multi Level Feedback Queue)
多级回馈队列 (Multi Level Feedback Queue，后面简称MLFQ)是[Fernando J. Corbató](https://en.wikipedia.org/wiki/Fernando_J._Corbat%C3%B3)在1962年发明的，并因此获得了图灵奖。BSD Unix, Solaris和Windows NT都用MLFQ作为其调度器。现在的Win10都还在使用。

多级反馈队列无需预先知道任务的运行时长，也无需知道任务类型，通过任务运行获得反馈信息，来认定任务是偏完成时间还是偏响应时间，并且动态调整优先级。偏向完成时间也即CPU bound型，偏向交互时间即IO bound型（后面只用CPU bound和IO bound这两个词了）。

MLFQ有多个队列，从上到下，每个队列的优先级依次降低，每个队列中都有多个任务，同一个队列中的任务优先级一致。

规则：

1. 如果A的优先级大于B，则运行A
2. 如果A和B的优先级一致，则A和B轮流执行(RR)
3. 新加入的任务放在最高优先级
4. 优先级回馈调整
    + 如果一个任务一口气用完了它的时间片，则降低它的优先级
    + 如果一个任务还没有用它的时间片就放弃了CPU，则优先级保持不变
5. 每过一段时间，提升所有任务到最高优先级

新加入的任务由于不知道是CPU bound还是IO bound，所以放在最高优先级，当他运行的时候，一口气用完了自己的时间片，那能推测它大概率是CPU bound，所以降低优先级，让位给IO bound的任务。反之，如果它还没有用完时间片就放弃了，则表明它是IO bound的，所以保留它的优先级。在一个系统中，IO bound的也可能某个时间片扮演CPU bound的角色，因此，过了一段时间后，所有任务都可能下降了优先级，所以将他们放入最高优先级队列，重新竞争。

![mlfq-8](/images/mlfq-8.jpg)

图中是两个任务，黑色（CPU bound型），灰色（IO bound型）的调度情况，CPU bound型的任务每次都花完了自己的时间片，因此快速降到了最低优先级，而灰色的IO bound型任务每次都花不完自己的时间片就放弃了CPU，所以优先级一直没变。可以知道，IO bound型任务优先调度，响应速度更快，他们也更快释放CPU，释放的CPU被低优先级的任务拿到，然后执行自己的任务，消耗完自己的时间片。

### 等等？Outlier?
以上算法有两个问题：

1. **饥饿**：如果交互任务过多，调度器每次都选择了交互任务，则低优先级的任务可能饥饿
2. **攻击**：用户可以修改自己的任务，先执行CPU bound类指令，在最后关头执行某个无用的IO操作，以此来避免优先级降低

解决这个的办法是修改规则4

**一旦一个任务用完了自己的时间片（不管几次用完），降低优先级**

对于饥饿情况，由于不管CPU bound还是IO bound都要降级，所以低优先级的任务得到机会运行。对于攻击，由于临时调用IO操作并不能保持住自己的优先级，所以显得毫无意义。

因此，规则可以描述为

1. 如果A的优先级大于B，则运行A
2. 如果A和B的优先级一致，则A和B轮流执行(RR)
3. 新加入的任务放在最高优先级
4. 一旦一个任务用完了自己的时间片（不管几次用完），降低优先级
5. 每过一段时间，提升所有任务到最高优先级

### 参数
可以看到，要控制MLFQ的话，参数比较多，队列到底应该有多少个？高优先级和低优先级队列的时间片是否应该不一样长，不一样长又应该各有多长？这些问题都依于实现，并没有一个标准。比如，Solaris的MLFQ 实现把这个问题交给了用户，管理员可以控制这堆参数。FreeBSD用了公式来计算优先级，等等。

## 一些问题
+ 由于大数据调度的任务都不是交互式的，只是batch任务，所以在预知数据的量级的情况下，会不会使用SCTF方式调度？

## Reference

+ *Operating Systems: Three Easy Pieces* https://pages.cs.wisc.edu/~remzi/OSTEP/
+ *Multilevel feedback queue* https://en.wikipedia.org/wiki/Multilevel_feedback_queue
